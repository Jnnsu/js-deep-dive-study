## 4.1 변수란 무엇인가? 왜 필요한가?
---
- Application은 데이터를 다룬다. 많은 함수와 프로그래밍 되어있지만 결국 아래와 같은 과정의 반복이다. 

### 4.1.1 컴퓨터가 연산하는 과정
- 데이터를 `입력`받아 (Input Device)
- `처리`를 하여 (CPU & Memory)
- 결과를 `출력` 하는 것이 전부이다. (Output Device)

![](https://i.imgur.com/jJtMUer.png)

우리가 브라우저상에서 키보드로 아래의 코드를 치면 30이라는 결과가 나온다.
```
console.log(10+20);
```
- 우리가 키보드로 10 + 20 를 입력하면
- 자바스크립트 엔진이 10과 20을 Memory에 기억하고
	- 피연산자(operand)라고 하는데 여기서 피(被)는 받다, 당하다 즉 연산을 당하는 대상이라고 이해하면 된다.
- CPU는 메모리에 올라와 있는 데이터를 계산(또는 연산)하고
- 연산 결과를 메모리에 저장합니다.
- 그리고 그 결과를 우리는 확인할 수 있습니다.

### 4.1.2 한발짝 더 들어가기
여기에서 한단계 더 들어가 보겠습니다. 컴퓨터 개론을 공부한다는 느낌으로요.

기본적으로 우리가 작성한 코드 파일은 하나의 파일에 불과합니다. 조금 더 과장해서 이야기하면 글자의 덩어리에 불과합니다.

컴퓨터는 아래 단계를 통해 코드를 분석합니다.
1. **소스 코드 로드** : 자바스크립트 소스코드가 `메모리`에 로드
2. **파싱** : 자바스크립트 엔진 `파서(parser)`는 로드된 소스코드와 구문을 분석
3. **연산자 처리와 실행**: 연산자 `+`는 자바스크립트 엔진에 의해 처리되고, CPU가 이해할 수 있는 저수준의 기계어 명령으로 변환  CPU는 이 명령을 사용하여 `10`과 `20`의 덧셈 연산을 수행
4. 결과를 **메모리에 저장**

![](https://i.imgur.com/OfbXequ.png)

#### 4.1.2.1 용어정리
1. **리터럴(Literal)**: 소스 코드 내에서 **고정된 값을 나타내는 표현**입니다. 예를 들어, `100`, `'안녕하세요'`, `true`와 같은 값, 이 데이터 자체로 의미가 있고 변수에 할당할 수 있다.
    
2. **연산자(Operator)**: 연산자는 데이터에 대해 연산을 수행하는 기호 예를 들어, `+`, `-`, `*`, `/`는 산술 연산자로, 더하기, 빼기, 곱하기, 나누기를 수행합니다. `==`, `!=`, `>`, `<`와 같은 비교 연산자는 두 값의 비교를 수행합니다.
    
3. **표현식(Expression)**: 표현식은 **값, 변수, 연산자의 조합**으로, 계산되었을 때 하나의 값으로 평가됩니다. 예를 들어, `5 + 3`, `x * y`, `age > 18`와 같은 구문들은 모두 표현식입니다.
    
4. **파싱(Parsing)**: 파싱은 문자열 형태의 코드를 컴퓨터가 이해할 수 있는 구조(이진 코드)로 변환하는 과정입니다. 예를 들어, 자바스크립트 엔진은 HTML 문서에 포함된 자바스크립트 코드를 읽고, 이를 실행 가능한 명령어로 변환하는 과정에서 파싱을 사용합니다.
    

### 4.1.3 변수(Variable)

- 변수는 쉽게 이야기해서 **변할수 있는 수**
- 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.
- 그렇기 때문에 우리는 앞에 작성했던 10, 20, 결과 값인 30에 다시 접근할 수 없다.
- 설사 10 + 20을 하더라도 메모리 상으로는 다른 위치에 저장될 수도 있다.
- 이는 메모리의 낭비이므로**이를 재사용하기 위해 만든게 변수 이다.**

변수는 값을 **재사용**하기 위해서 **값의 위치를 가리키는 **상징적인 이름**이다.
그래서 우리는 변수의 이름을 **식별자(Identifier)** 이라고도 한다.

## 4.2 식별자
**식별자란 어떤 값을 구별해서 식별할 수 있는 고유한 이름**
```javascript
let result = 30;
```
![](https://i.imgur.com/ZWLINFE.png)

변수는 메모리에 있는 값을 재 사용하기 위해 만들었기 때문에 result라는 변수이름 즉 **식별자는 메모리 주소를 가리키고 있다.**

그렇기 때문에 우리는 메모리 주소를 모르더라도 (사실 주소 접근이 안되지만) 메모리 상에 존재하는 공간을  사용할수 있다. 

이를 사용하기 위해서는 **선언을 해야 한다.**

## 4.3 변수 선언
변수를 선언할때는 var, let, const 키워드를 사용 한다.


아래 처럼 변수를 선언하면 변수 이름을 **등록** 하고 값을 저장할 메모리 공간을 확보한다.
```javascript
var score; //변수 선언문
```
- var 키워드로 변수를 선언하면 초기화가 동시에 진행된다.
- 선언하면 변수 이름 score을 등록 하고
- 암묵적으로 undefined 를 초기화(최초로 값을 할당)
	- 이러한 초기화는 메모리 공간에 쓰레기 값(이전에 사용된)을 정리해주는 역할을 한다.
![](https://i.imgur.com/gXvIchq.png)

## 4.4 변수 호이스팅
---
```javascript
console.log(score); //undefined

var score;
```
자바스크립트 코드는 인터프리터에 의해 한줄씩 순차적으로 실행된다.
하지만 위의 `console.log(score)` 코드는 정상적으로 작동한다.

그 이유는 **변수 선언이 소스코드가 한 줄씩 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

1. **소스 코드 로드** : 자바스크립트 소스코드가 `메모리`에 로드
2. **파싱** : 자바스크립트 엔진 `파서(parser)`는 로드된 소스코드와 구문을 분석
3. **호이스팅(Hoisting)**: 자바스크립트에서 함수 선언과 `var`로 선언된 변수는 호이스팅 즉  **선언된 위치와 관계없이 코드 실행 전에 메모리에 할당**
4. **변수 초기화** : `var`로 선언된 변수는 `undefined`로 초기화
5. **함수 선언** : 함수를 호이스팅 하여 메모리에 할당한다.
6. **코드 실행 준비** : 실행 컨텍스트(Execution Context) 생성, 

여기에서 주의 할점
- 변수 선언은 실제 실행되는(런타임) 시점 이전에 진행, var의 경우 초기화도 진행
- 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.

> 참고 **let** 으로 선언한 변수는 초기화 되지 않는 상태로 초기화 되고, 변수가 선언된 위치에 접근하기 전에 가면 참조 오류(Reference Error)이 발생한다.
```javascript
console.log(a); // undefined
var a = 5;
console.log(b); // ReferenceError: b is not defined
let b = 5;
```