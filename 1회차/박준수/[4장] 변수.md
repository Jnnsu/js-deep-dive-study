# [4장] 변수

## 변수란?

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 메모리 공간을 식별하기 위해 붙인 이름

값의 위치를 가리키는 상징적인 이름
<br>
<br>
<br>
## 변수를 사용해야 되는 이유

값은 메모리의 메모리 셀에 저장되고, 각 셀은 고유의 주소가 있다. 하지만 이 주소를 통해 저장한 값에 접근해서는 안된다. 
<br>
<br>
### 메모리 주소를 통해 저장된 값에 접근하면 안되는 이유

- **코드가 실행되기 이전에는 값이 저장된 메모리 주소를 알 수 없다.**
    
    값이 저장될 때 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정된다. 동일한 컴퓨터에서 동일한 코드를 실행해도 코드가 실행될 때마다 메모리 주소는 변경된다.
    
- **치명적인 오류를 발생시킬 수 있어 매우 위험하다.**
    
    만약 실수로 운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 할 수도 있다.
    
    그래서 자바스크립트는 개발자가 직접 메모리 제어를 하도록 허용하지 않는다.
    

이와 같은 이유로 직접 메모리 주소를 통해 값에 접근하는 것 보다 변수를 사용해 안전하게 값에 접근해야 한다.
<br>
<br>
### 변수의 사용

**변수 이름**은 사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름이다. **변수 이름**을 사용해 **참조**(변수에 저장된 값을 읽어 들이는 것)를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다.

**변수 이름**은 사람이 이해할 수 있는 언어로 명명되기 때문에 개발자들은 변수에 저장된 값의 의미를 명확히 알 수있다. 그래서 변수에 저장된 값의 의미를 파악할 수 있는 변수명은 가독성을 높이는 부수적인 효과도 있다.
<br>
<br>
<br>
## 식별자

어떤 값을 구별해서 식별할 수 있는 고유한 이름. 변수 이름을 **식별자** 라고도 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다. 다만 **식별자**는 변수명에만 사용하는 것이 아니고 변수, 함수, 클래스 등의 이름은 모두 **식별자**다.

```jsx
var result = 10 + 20;
```

위 코드에서 `result`가 **변수명**이자 **식별자**이다. 

식별자는 **네이밍 규칙**을 준수해야 하며, **선언**에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.
<br>
<br>
<br>
## 변수 선언

값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것

변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

```jsx
var score; // 변수 선언(변수 선언문)
```

자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 걸쳐 수행한다.

- **선언 단계**: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
- **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화한다.

초기화란? 선언된 이후 최초로 값을 할당하는 것 → 이전에 다른 애플리케이션이 사용했던 garbage value가 남아있을 수있기 때문
<br>
<br>
### 호이스팅

```jsx
console.log(score); // undefined
var score; // 변수 선언문
```

위와 같은 코드 처럼 변수 선언문보다 변수를 참조하는 코드가 앞에 있을 경우 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징이다.

어떻게 이런 일이 발생하는 걸까?

**변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**
<br>
<br>
### 값의 할당

```jsx
var score; // 변수 선언
score = 10; // 값의 할당
score = 90; // 값의 재할당
```

변수에 값을 할당할 때는 할당 연산자 `=` 를 사용하고 할당된 값을 버리고 새로운 값을 저장(재할당)할 수도 있다.

첫 값을 할당할 때와 재할당 할 때 모두 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장한다. 

위 코드는 아래와 같이 단축 표현할 수 있다.

```jsx
var score = 10; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

**변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**
<br>
<br>
<br>
## 식별자 네이밍 규칙

식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제회한 문자, 언더스코어(_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.

```jsx
var person, $elem, _name, first_name, vla1;

// 명명규칙에 위배되는 식별자
var first-name;
var 1st;
var this;
```

- 한글, 일본어등 사용 가능하다.
- 대소문자를 구분한다.

```jsx
// 3개의 변수
var firstname;
var firstName;
var FIRSTNAME;
```

- 변수나 함수는 camelCase를 사용
- 생성자 함수, 클래스 이름에는 PascalCase 사용
- 예약어는 식별자로 사용할 수 없다.

### 예약어

| await | break | case | catch | class | const |
| --- | --- | --- | --- | --- | --- |
| continue | debugger | default | delete | do | else |
| enum | export | extends | false | finally | for |
| function | if | implements | import | in | instanceof |
| interface | let | new | null | package | private |
| protected | public | return | super | static | switch |
| this | throw | true | try | typeof | var |
| void | while | with | yield |  |  |
