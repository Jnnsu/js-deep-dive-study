
> 💡 자바스크립트는 어떤 언어인가?

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 **<span style='color: #50bcdf'>멀티 패러다임 프로그래밍 언어</span>**이다.


<img width='200' src="https://mblogthumb-phinf.pstatic.net/MjAyMzA4MTlfMjcz/MDAxNjkyNDI0ODk4NTIy.nrTucGhkszQJZHV0VzceR-cYJsdi_FW2TLnbMkRLB2Ug.wRNED7RrxWDG2h4uOaYiUm6C19gEziZua2vXxPtp50gg.PNG.gi_balja/bbb.png?type=w800" />


자바스크립트엔 public, private, protected(클래스 기반 객체지향 프로그래밍 언어의 특징인 클래스와 상속, 캡슐화를 위한 키워드) 등이 없기에 아예 객체지향 언어가 아니라고 오해하곤 하지만, 더 효율적이고 강력한 기능을 가진 **<span style='color: #50bcdf'>프로토타입 기반 객체지향 프로그래밍 언어</span>**다!
<br>

그럼 자바스크립트에 대해 더 자세히 알아보기 위해 객체지향 프로그래밍 언어가 무엇인지부터 알아보자. 

<br>


# 📌 객체지향 프로그래밍이란?
---

객체지향 프로그래밍은 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.

### 절차지향? 객체지향?
  
절차지향과 객체지향은 **패러다임**을 뜻하는 단어로써, 어떠한 견해나 관점을 용어로 만든 것 뿐이다.
<img src='https://velog.velcdn.com/images%2Fgparkkii%2Fpost%2F58973972-ba22-4aac-962d-f23d31f06cf9%2Funnamed%20(1).png' />

절차지향 언어를 사용한다면, 말 그대로 **실행 순서**, 즉 **절차**가 더 중점이 되고,
객체지향 언어를 사용한다면, 필요한 객체들의 **종류와 속성(특징이나 성질)** 등이 더 중점이 된다.

객체지향 언어에서 "<span style='color: #50bcdf'>객체</span>"란, <span style='color: #50bcdf'>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조</span>를 말한다.
  
<br>

## 🌟 객체지향 프로그래밍 언어
 
> 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)은 프로그래밍에서 필요한 데이터를 추상화 시켜 `상태와 행위(동작)를 가진 객체`로 만들고, 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.


잠시 아래 예시를 보자.
  
<img width='700' src='https://i0.wp.com/blog.codestates.com/wp-content/uploads/2022/11/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B6%94%EC%83%81%ED%99%94.png?w=893&ssl=1'>

자동차와 오토바이는 모두 **이동 수단**이며 모든 이동 수단은 **전진**과 **후진**을 할 수 있다는 공통점을 가진다. 자동차와 오토바이라는 하위 객체의 **공통적인 기능**(전진과 후진)을 추출하여 이동 수단 이라는 상위 객체에 정의한다.

<br>
  
이처럼 객체 지향 프로그래밍에서 의미하는 추상화는 객체의 공통적인 속성과 기능을 추출하여 정의하는것을 의미한다.

여기서 객체의 상태 데이터를 **프로퍼티**, 동작을 **메서드**라 한다.
  
프로그래밍에서 각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만, 객체는 자신의 고유한 기능을 수행하면서 동시에 다른 **객체와의 관계성(다른 객체와 메세지를 주고받거나 데이터를 처리, 동작 <span style='color: orange'>상속</span>받기)**을 가질 수도 있다.
<br>


# 📌 상속
---

**<span style='color: orange'>상속</span>**은 객체지향 프로그래밍의 핵심 개념이다.
어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.
  
<img src='https://jongminfire.dev/static/375a067573d73f987cc12f19f7e7d341/bbfed/What-is-OOP.png' /> 

<br>

> 프로그래밍에서 상속이 왜 필요할까?

예를 들면 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유한다면 메모리를 불필요하게 낭비하게 된다. 또한 인스턴스를 생성할 때마다 메서드를 생성하므로 퍼포먼스에도 악영향을 준다.
  
결론적으로 **상속은 불필요한 중복을 제거해 메모리 낭비를 줄이기 위해 사용한다.**

<br>

  
### 자바스크립트에서의 상속

자바스크립트는 **<span style='color: orange'>prototype을 기반으로 상속을 구현</span>**한다.

```js
function Circle(radius) {
  this.radius = radius;
}

// 프로토타입
Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

// 인스턴스 생성
const circle1 = new Circle(1);
const cirecle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // true
console.log(circle1.getArea()); // 3.141592653589793
console.log(circle2.getARea()); // 12.566370614359172
```
`getArea` 메서드는 단 하나만 생성되어 prototype인 `Circle.prototype`의 메서드로 할당되어 있다. 
그러면 `Circle` 생성자 함수가 생성하는 모든 인스턴스는 자신의 상태를 나타내는 `radius` 프로퍼티만 개별적으로 소유하고 내용이 동일한 `getArea` 메서드를 상속받아 사용할 수 있다. 

이렇게 prototype에 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 **<span style='color: orange'>상위(부모) 객체인 prototype의 자산을 상속</span>**받아 사용할 수 있고 이는 코드의 재사용이란 관점에서 매우 유용하다.
<br>


# 📌 prototype 객체
---
>prototype 객체란 어떤 객체의 부모 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다.

모든 객체는 `[[Protoype]]`이라는 내부 슬롯을 가진다.
이 내부 슬롯의 값은 prototype의 참조(`null`인 경우도 있다.)다.

객체 리터럴에 의해 생성된 객체의 prototype은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 prototype은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체다.

즉, **<span style="color: orange">객체가 생성될 때 객체 생성방식에 따라 prototype이 결정되고 자신의 `[[Prototype]]`에 저장</span>**된다.

prototype에 접근할 때 `[[Prototype]]` 내부슬롯을 이용해야 하는데, 직접 접근할 수는 없다. 하지만 **<span style="color: orange">`__proto__`</span>** 접근자 프로퍼티를 통해 간접적으로 접근할 수는 있다.
<br>

##  `__proto__` 접근자 프로퍼티
> 💡 접근자 프로퍼티란?
접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수, 즉 `[[Get]]`, `[[Set]]` 프로퍼티 어트리뷰트로 구성된 프로퍼티다.

모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 prototype, 즉 `[[Prototype]]` 내부슬롯에 간접적으로 접근할 수 있다.
<br>

다음 예제를 크롬 브라우저의 콘솔에 출력해보면
```js
const student = { name: 'Lee', score: 90 };
```
<img src='https://poiemaweb.com/img/printout_student_obj_from_chrome.png' width="600"/>

그림의 빨간 박스로 표시한 것이 student 객체의 prototype인 Object.prototype이다. 이는 `__proto__` 접근자 프로퍼티를 통해 `[[Prototype]]`에 접근한 결과를 크롬 브라우저가 콘솔에 표시한 것이다.
<br>

`__proto__`는 getter/setter 함수(접근자 함수: `[[Get]]`, `[[Set]` <span style='color: #50bcdf'>프로퍼티 어트리뷰트</span>❇︎에 할당된 함수)를 통해 `[[Prototype]]` 내부 슬롯의 값을 취득하거나 할당한다.


- <span style='color: #50bcdf'>프로퍼티 어트리뷰트</span>

  프로퍼티는 해당 프로퍼티가 어떤 프로퍼티인지 명시된 설명서 같은게 있는데,
그 <span style='color: #50bcdf'>설명서(프로퍼티 디스크립터)에 명시된 프로퍼티의 속성들이 프로퍼티 어트리뷰트</span>다. 자바스크립트 엔진은 이 설명서를 보고 프로퍼티를 어떻게 처리할지 결정한다.

<br>

> 💡 `__proto__` 접근자 프로퍼티는 해당 객체에 포함된 프로퍼티일까?
-> No.

`__proto__`는 객체가 직접 소유하는 것이 아니라 `Object.prototype`의 프로퍼티다. 모든 객체는 상속을 통해 `Object.prototype.__proto__`를 사용하는 것이다.

<br>

### 왜 사용할까?

**<span style='color: orange'>prototype에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 prototype 체인이 생성되는 것을 방지하기 위해서다.</span>**

이게 무슨 말이냐면, 아래의 예시처럼 서로가 서로의 부모 객체가 될 수 없다는 이야기다.
```js
const parent = {};
const child = {};

child.__proto__ = parent;
parent.__proto__ = child; // TypeError: Cycle __proto__ value
```
프로퍼티 검색 방향은 한쪽 방향으로만 흘러가야 한다.
만약 서로가 자신의 prototype이 되며 순환 참조하는 프로토타입 체인이 만들어지면 프로토타입 체인에서 프로퍼티를 검색할 때 체인의 종점이 존재하지 않기 떄문에 **<span style='color: red'>무한 루프에 빠진다.</span>**


따라서 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 `__proto__` 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있는 것이다.
<br>


하지만 코드 내에서 직접 사용하는 것은 권장하지 않는다.
모든 객체가 `__proto__` 접근자 프로퍼티를 사용할 수 있는 것은 아니기 떄문이다.(`Object.prototype`을 상속받지 않는 객체를 생성하는 경우)

<br>

> 💡 그럼 `__proto__` 대신 뭘 사용해야 할까?

프로퍼티 참조를 취득하고 싶은 경우에는 `Object.getPrototypeOf` 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 `Object.setPrototypeOf` 메서드를 사용할 것을 권장한다.

<br>

## 함수 객체의 prototype 프로퍼티

>함수가 생성될 때 prototype 프로퍼티가 같이 생성된다. 이 prototype 프로퍼티는 그 함수를 생성자로 사용했을 때 만들어지는 객체들이 공통으로 사용할 수 있는 속성이나 메서드를 저장하는 곳이다.

예를 들어,
```js
function Person(name) { this.name = name; }
```
이런 식으로 생성자 함수를 만들면, `Person` 함수 객체에는 prototype 이라는 프로퍼티가 자동으로 생성된다. 그리고 `Person` 생성자 함수로 새 객체를 만들 때, 이 새 객체는 `Person.prototype`을 상속받는다. 
이렇게 해서 모든 인스턴스가 `Person.prototype`에 정의된 속성이나 메서드를 공유할 수 있게 되는 것이다.
<br>

하지만 **화살표 함수나 ES6에서소개된 메서드 축약 표현으로 만든 함수**는 다르다. 이 두 종류의 함수는 'non-constructor' 함수라고 불리는데, 이 말은 **이 함수들로 새로운 객체를 만들어내는 생성자로 사용할 수 없다**는 뜻이다.그래서 이 함수들은 **prototype 프로퍼티도 가지고 있지 않고, 프로토타입도 만들지 않는다.**
  
즉, 화살표 함수나 메서드 축약 표현으로 만든 함수들은 주로 콜백 함수나 메서드로 사용되며, 객체를 생성하는 용도로는 쓰이지 않아서 prototype 프로퍼티나 프로토타입이 필요 없다.

또 **일반 함수(함수 선언문, 함수 표현식)**도 prototype 프로퍼티를 소유하지만 객체를 생성하지 않기 때문에 아무런 의미가 없다.

그래서 **<span style='color: orange'>모든 객체가 `Object.prototype`으로부터 상속받은 `__proto__` 접근자 프로퍼티</span>**와 **<span style='color: orange'>함수 객체만이 가지고 있는 prototype 프로퍼티</span>**는 결국 **<span style='color: orange'>동일한 프로토타입을 가리킨다.</span>**

| 구분 | 소유 | 값 | 사용주체 | 사용목적 |
|-|-|-|-|-|
| `__proto__`접근자 프로퍼티 | 모든 객체 | 프로토타입의 참조 | 모든 객체 | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용 |
| prototype 프포퍼티 | constructor | 프로퍼티의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성한 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |





  
 

<br>  
<br>
<br>
<br>
 
